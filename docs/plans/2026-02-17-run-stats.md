# Run Stats & Strategy Auto-Update Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Automatically record per-round game stats during each run, then after each run have Claude analyze the data and rewrite `docs/strategy.md` with refined findings.

**Architecture:** `StatsRecorder` writes to two new tables in `tft.db`. `vision_loop` detects round transitions and run boundaries, calling `StatsRecorder` methods. After each completed/eliminated run, `StrategyEngine.update_strategy()` queries recent runs, calls Claude, and overwrites `strategy.md`.

**Tech Stack:** SQLite (existing tft.db), Python threading, Anthropic API (existing)

---

### Context for implementer

- Python venv at `/home/adam/tft/.venv` — use `.venv/bin/pytest`, `.venv/bin/python`
- DB at `/home/adam/tft/tft.db`, accessed via `StrategyEngine(db_path)` which holds `self.conn`
- `overlay/strategy.py` has module-level `_STRATEGY` (str) and `_STRATEGY_FILE` (Path) — strategy.md content loaded at import time
- `overlay/main.py:vision_loop()` is the background thread that reads game state each frame
- `GameState.round_number` is a string like `"1-3"` or None; `GameState.items_on_bench` is a list (its length = component count)
- Run tests with: `.venv/bin/pytest tests/ -v`
- All existing 11 tests must stay passing

---

### Task 1: `ensure_stats_tables` + `StatsRecorder`

**Files:**
- Create: `overlay/stats.py`
- Create: `tests/test_stats.py`

**Step 1: Write the failing tests**

```python
# tests/test_stats.py
import sqlite3
import pytest
from overlay.stats import ensure_stats_tables, StatsRecorder


@pytest.fixture
def conn():
    c = sqlite3.connect(":memory:")
    c.row_factory = sqlite3.Row
    ensure_stats_tables(c)
    return c


def test_ensure_creates_tables(conn):
    tables = {r[0] for r in conn.execute(
        "SELECT name FROM sqlite_master WHERE type='table'"
    ).fetchall()}
    assert "runs" in tables
    assert "run_rounds" in tables


def test_ensure_idempotent(conn):
    # Calling twice should not raise
    ensure_stats_tables(conn)


def test_start_run_inserts_row(conn):
    rec = StatsRecorder(conn)
    rec.start_run()
    assert rec.active_run_id is not None
    row = conn.execute("SELECT * FROM runs WHERE id = ?", (rec.active_run_id,)).fetchone()
    assert row is not None
    assert row["started_at"] is not None
    assert row["end_reason"] is None


def test_record_round_inserts_row(conn):
    rec = StatsRecorder(conn)
    rec.start_run()
    rec.record_round("1-1", gold=10, level=2, lives=3,
                     component_count=5, shop=["Jinx", "Vi"])
    rows = conn.execute("SELECT * FROM run_rounds WHERE run_id = ?",
                        (rec.active_run_id,)).fetchall()
    assert len(rows) == 1
    assert rows[0]["round_number"] == "1-1"
    assert rows[0]["gold"] == 10
    assert rows[0]["component_count"] == 5


def test_items_built_inferred(conn):
    rec = StatsRecorder(conn)
    rec.start_run()
    rec.record_round("1-1", gold=10, level=2, lives=3,
                     component_count=5, shop=[])
    rec.record_round("1-2", gold=12, level=2, lives=3,
                     component_count=3, shop=[])  # built 2 items
    rows = conn.execute("SELECT * FROM run_rounds ORDER BY id").fetchall()
    assert rows[0]["items_built"] == 0  # no previous — first round
    assert rows[1]["items_built"] == 2


def test_life_lost_inferred(conn):
    rec = StatsRecorder(conn)
    rec.start_run()
    rec.record_round("1-1", gold=10, level=2, lives=3,
                     component_count=5, shop=[])
    rec.record_round("1-2", gold=10, level=2, lives=2,
                     component_count=5, shop=[])  # lost a life
    rows = conn.execute("SELECT * FROM run_rounds ORDER BY id").fetchall()
    assert rows[0]["life_lost"] == 0
    assert rows[1]["life_lost"] == 1


def test_end_run_updates_row(conn):
    rec = StatsRecorder(conn)
    rec.start_run()
    run_id = rec.active_run_id
    rec.record_round("1-1", gold=10, level=2, lives=3,
                     component_count=5, shop=[])
    rec.end_run("eliminated")
    assert rec.active_run_id is None
    row = conn.execute("SELECT * FROM runs WHERE id = ?", (run_id,)).fetchone()
    assert row["end_reason"] == "eliminated"
    assert row["ended_at"] is not None
    assert row["rounds_completed"] == 1


def test_record_round_no_active_run_is_noop(conn):
    rec = StatsRecorder(conn)
    rec.record_round("1-1", gold=10, level=2, lives=3,
                     component_count=5, shop=[])
    rows = conn.execute("SELECT * FROM run_rounds").fetchall()
    assert len(rows) == 0
```

**Step 2: Run tests to verify they fail**

```bash
.venv/bin/pytest tests/test_stats.py -v
```
Expected: FAIL with `ModuleNotFoundError: No module named 'overlay.stats'`

**Step 3: Implement `overlay/stats.py`**

```python
import json
import sqlite3
from datetime import datetime, timezone


def ensure_stats_tables(conn: sqlite3.Connection) -> None:
    conn.executescript("""
        CREATE TABLE IF NOT EXISTS runs (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            started_at TEXT,
            ended_at TEXT,
            rounds_completed INTEGER DEFAULT 0,
            end_reason TEXT
        );
        CREATE TABLE IF NOT EXISTS run_rounds (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            run_id INTEGER REFERENCES runs(id),
            round_number TEXT,
            gold INTEGER,
            level INTEGER,
            lives INTEGER,
            component_count INTEGER,
            shop TEXT,
            items_built INTEGER,
            life_lost INTEGER
        );
    """)
    conn.commit()


class StatsRecorder:
    def __init__(self, conn: sqlite3.Connection):
        self.conn = conn
        self._run_id: int | None = None
        self._rounds_completed = 0
        self._prev_components: int | None = None
        self._prev_lives: int | None = None

    @property
    def active_run_id(self) -> int | None:
        return self._run_id

    def start_run(self) -> None:
        now = datetime.now(timezone.utc).isoformat()
        cur = self.conn.execute(
            "INSERT INTO runs (started_at, rounds_completed) VALUES (?, 0)",
            (now,),
        )
        self.conn.commit()
        self._run_id = cur.lastrowid
        self._rounds_completed = 0
        self._prev_components = None
        self._prev_lives = None

    def record_round(self, round_number: str, gold: int | None,
                     level: int | None, lives: int | None,
                     component_count: int, shop: list[str]) -> None:
        if self._run_id is None:
            return
        items_built = max(
            0,
            (self._prev_components if self._prev_components is not None
             else component_count) - component_count,
        )
        life_lost = (
            1 if self._prev_lives is not None
            and lives is not None
            and lives < self._prev_lives
            else 0
        )
        self.conn.execute(
            """INSERT INTO run_rounds
               (run_id, round_number, gold, level, lives, component_count,
                shop, items_built, life_lost)
               VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)""",
            (self._run_id, round_number, gold, level, lives, component_count,
             json.dumps(shop), items_built, life_lost),
        )
        self._rounds_completed += 1
        self.conn.execute(
            "UPDATE runs SET rounds_completed = ? WHERE id = ?",
            (self._rounds_completed, self._run_id),
        )
        self.conn.commit()
        self._prev_components = component_count
        self._prev_lives = lives

    def end_run(self, reason: str) -> None:
        if self._run_id is None:
            return
        now = datetime.now(timezone.utc).isoformat()
        self.conn.execute(
            "UPDATE runs SET ended_at = ?, end_reason = ? WHERE id = ?",
            (now, reason, self._run_id),
        )
        self.conn.commit()
        self._run_id = None
```

**Step 4: Run tests to verify they pass**

```bash
.venv/bin/pytest tests/test_stats.py -v
```
Expected: All 9 tests PASS.

**Step 5: Run all tests to verify nothing broken**

```bash
.venv/bin/pytest tests/ -v
```
Expected: All tests pass.

**Step 6: Commit**

```bash
git add overlay/stats.py tests/test_stats.py
git commit -m "feat: add StatsRecorder and ensure_stats_tables"
```

---

### Task 2: Auto-create stats tables in StrategyEngine + build_db

**Files:**
- Modify: `overlay/strategy.py` (add `ensure_stats_tables` call in `__init__`)
- Modify: `build_db.py` (add tables to `create_schema`)

**Step 1: Add to `StrategyEngine.__init__`**

In `overlay/strategy.py`, add import at the top:
```python
from overlay.stats import ensure_stats_tables
```

In `StrategyEngine.__init__`, after `self.conn.row_factory = sqlite3.Row`, add:
```python
ensure_stats_tables(self.conn)
```

**Step 2: Add tables to `build_db.py:create_schema`**

In `build_db.py`, inside `create_schema(conn)`, add to the `executescript` string (after `DROP TABLE IF EXISTS enemy_units;` and before `CREATE TABLE scoring_rules`):

```sql
DROP TABLE IF EXISTS run_rounds;
DROP TABLE IF EXISTS runs;

CREATE TABLE runs (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    started_at TEXT,
    ended_at TEXT,
    rounds_completed INTEGER DEFAULT 0,
    end_reason TEXT
);

CREATE TABLE run_rounds (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    run_id INTEGER REFERENCES runs(id),
    round_number TEXT,
    gold INTEGER,
    level INTEGER,
    lives INTEGER,
    component_count INTEGER,
    shop TEXT,
    items_built INTEGER,
    life_lost INTEGER
);
```

**Step 3: Run all tests**

```bash
.venv/bin/pytest tests/ -v
```
Expected: All tests pass.

**Step 4: Commit**

```bash
git add overlay/strategy.py build_db.py
git commit -m "feat: auto-create stats tables in StrategyEngine and build_db"
```

---

### Task 3: `StrategyEngine.update_strategy()` + `reload_strategy()`

**Files:**
- Modify: `overlay/strategy.py`
- Modify: `tests/test_strategy_ai.py`

**Step 1: Write failing tests**

Add to `tests/test_strategy_ai.py`:

```python
from unittest.mock import patch, MagicMock
import sqlite3
from overlay.stats import ensure_stats_tables, StatsRecorder
import overlay.strategy as strategy_module


def _make_engine_with_runs():
    """Create an in-memory engine with two completed runs."""
    from overlay.strategy import StrategyEngine
    engine = StrategyEngine(":memory:")
    # Seed two runs with round data
    rec = StatsRecorder(engine.conn)
    for _ in range(2):
        rec.start_run()
        rec.record_round("1-1", gold=10, level=2, lives=3,
                         component_count=5, shop=["Jinx"])
        rec.record_round("1-2", gold=14, level=2, lives=3,
                         component_count=5, shop=["Vi"])
        rec.end_run("eliminated")
    return engine


def test_update_strategy_calls_claude_and_writes_file(tmp_path):
    engine = _make_engine_with_runs()

    mock_response = MagicMock()
    mock_response.content = [MagicMock(text="# Updated Strategy\nNew findings.")]
    mock_response.stop_reason = "end_turn"

    with patch("overlay.strategy.Anthropic") as mock_cls:
        mock_client = MagicMock()
        mock_cls.return_value = mock_client
        mock_client.messages.create.return_value = mock_response

        # Patch file path to tmp
        strategy_file = tmp_path / "strategy.md"
        strategy_file.write_text("# Old Strategy", encoding="utf-8")
        with patch.object(strategy_module, "_STRATEGY_FILE", strategy_file):
            engine.update_strategy()

        assert mock_client.messages.create.called
        assert strategy_file.read_text(encoding="utf-8") == "# Updated Strategy\nNew findings."


def test_update_strategy_skips_if_no_runs():
    from overlay.strategy import StrategyEngine
    engine = StrategyEngine(":memory:")

    with patch("overlay.strategy.Anthropic") as mock_cls:
        engine.update_strategy()
        mock_cls.assert_not_called()


def test_update_strategy_reloads_global(tmp_path):
    engine = _make_engine_with_runs()

    mock_response = MagicMock()
    mock_response.content = [MagicMock(text="# Fresh Strategy")]
    mock_response.stop_reason = "end_turn"

    with patch("overlay.strategy.Anthropic") as mock_cls:
        mock_client = MagicMock()
        mock_cls.return_value = mock_client
        mock_client.messages.create.return_value = mock_response

        strategy_file = tmp_path / "strategy.md"
        strategy_file.write_text("# Old", encoding="utf-8")
        with patch.object(strategy_module, "_STRATEGY_FILE", strategy_file):
            engine.update_strategy()

        assert strategy_module._STRATEGY == "# Fresh Strategy"
```

**Step 2: Run tests to verify they fail**

```bash
.venv/bin/pytest tests/test_strategy_ai.py -v -k "update_strategy"
```
Expected: FAIL with `AttributeError: 'StrategyEngine' object has no attribute 'update_strategy'`

**Step 3: Implement `reload_strategy` and `update_strategy` in `overlay/strategy.py`**

Add `reload_strategy` after `_STRATEGY = _load_strategy()`:

```python
def reload_strategy() -> None:
    global _STRATEGY
    _STRATEGY = _load_strategy()
```

Add `update_strategy` method to `StrategyEngine` class:

```python
def update_strategy(self) -> None:
    """Query recent runs, ask Claude to refine docs/strategy.md, reload in memory."""
    import overlay.strategy as _self_module

    runs = self.conn.execute("""
        SELECT id, started_at, rounds_completed, end_reason
        FROM runs
        WHERE end_reason != 'abandoned'
        ORDER BY id DESC LIMIT 20
    """).fetchall()

    if not runs:
        return

    lines = ["# Run History Summary\n"]
    for run in runs:
        lines.append(
            f"## Run {run['id']} ({run['end_reason']}, "
            f"{run['rounds_completed']} rounds)"
        )
        lines.append(
            "| Round | Gold | Level | Lives | Components | "
            "Items Built | Life Lost |"
        )
        lines.append(
            "|-------|------|-------|-------|------------|"
            "-------------|-----------|"
        )
        rounds = self.conn.execute("""
            SELECT round_number, gold, level, lives,
                   component_count, items_built, life_lost
            FROM run_rounds WHERE run_id = ? ORDER BY id
        """, (run["id"],)).fetchall()
        for r in rounds:
            lines.append(
                f"| {r['round_number']} | {r['gold']} | {r['level']} "
                f"| {r['lives']} | {r['component_count']} "
                f"| {r['items_built']} | {r['life_lost']} |"
            )
        lines.append("")

    run_summary = "\n".join(lines)
    current_strategy = (
        _STRATEGY_FILE.read_text(encoding="utf-8")
        if _STRATEGY_FILE.exists() else ""
    )

    client = Anthropic()
    response = client.messages.create(
        model=CLAUDE_MODEL,
        max_tokens=2000,
        system=(
            "You are a TFT Tocker's Trials strategy optimizer. "
            "Analyze the run history and rewrite the strategy guide to "
            "reflect findings. Keep the same markdown format. "
            "Be concise and fact-driven. Only update sections where the "
            "data shows clear patterns."
        ),
        messages=[{
            "role": "user",
            "content": (
                f"Current strategy guide:\n\n{current_strategy}\n\n"
                f"Run history:\n\n{run_summary}\n\n"
                "Rewrite the strategy guide incorporating findings from "
                "the run history."
            ),
        }],
    )
    new_strategy = response.content[0].text
    _STRATEGY_FILE.write_text(new_strategy, encoding="utf-8")
    _self_module._STRATEGY = new_strategy
```

**Step 4: Run tests**

```bash
.venv/bin/pytest tests/ -v
```
Expected: All tests pass.

**Step 5: Commit**

```bash
git add overlay/strategy.py tests/test_strategy_ai.py
git commit -m "feat: add update_strategy and reload_strategy to StrategyEngine"
```

---

### Task 4: Wire `StatsRecorder` into `vision_loop`

**Files:**
- Modify: `overlay/main.py`

**Step 1: Read current `main.py`** (already provided in context above)

**Step 2: Replace `vision_loop` with the new version**

Replace the entire `vision_loop` function in `overlay/main.py` with:

```python
def vision_loop(capture, reader, engine, overlay, companion, stop_event):
    """Background thread: capture frames, read game state, update overlay."""
    from overlay.stats import StatsRecorder
    recorder = StatsRecorder(engine.conn)
    prev_round: str | None = None

    try:
        while not stop_event.is_set():
            frame = capture.grab()
            if frame is None:
                time.sleep(0.5)
                continue

            state = reader.read(frame)
            num_components = len(state.items_on_bench)
            gold = state.gold or 0
            current_round = state.round_number  # e.g. "1-3" or None

            # --- Round transition detection ---
            if current_round is not None and current_round != prev_round:
                if current_round == "1-1":
                    # New run starting
                    if recorder.active_run_id is not None:
                        recorder.end_run("abandoned")
                    recorder.start_run()
                elif prev_round is not None:
                    # Record the round that just ended
                    recorder.record_round(
                        round_number=prev_round,
                        gold=state.gold,
                        level=state.level,
                        lives=state.lives,
                        component_count=num_components,
                        shop=state.shop or [],
                    )

                    # Check if round 30 just completed
                    if prev_round == "3-10":
                        recorder.end_run("completed")
                        threading.Thread(
                            target=engine.update_strategy, daemon=True
                        ).start()

                prev_round = current_round

            # Check for elimination (lives hit 0)
            if state.lives == 0 and recorder.active_run_id is not None:
                recorder.record_round(
                    round_number=current_round or prev_round or "unknown",
                    gold=state.gold,
                    level=state.level,
                    lives=0,
                    component_count=num_components,
                    shop=state.shop or [],
                )
                recorder.end_run("eliminated")
                threading.Thread(
                    target=engine.update_strategy, daemon=True
                ).start()
                prev_round = None

            # --- Overlay update ---
            abs_round = _round_str_to_int(current_round)
            rounds_remaining = max(0, 30 - abs_round)

            projection = engine.projected_score(
                current_round=abs_round,
                num_components=num_components,
                gold=gold,
                surviving_units=len(state.my_board),
            )

            enemy_name = ""
            next_round_num = abs_round + 1
            if next_round_num <= 30:
                info = engine.get_round_info(next_round_num)
                if info:
                    enemy_name = (
                        f"Stage {info['stage']}-{info['round_in_stage']} "
                        f"({info['round_type']})"
                    )

            companion.update_game_state(state, projected_score=projection["total"])

            overlay.update_signal.emit({
                "score": projection["total"],
                "components": num_components,
                "component_value": engine.component_score(
                    num_components, rounds_remaining
                ),
                "round": abs_round,
                "enemy_name": enemy_name,
                "gold": gold,
                "advice": "",
            })

            time.sleep(1.0 / CAPTURE_FPS)

    finally:
        if recorder.active_run_id is not None:
            recorder.end_run("abandoned")
```

Also add this helper function above `vision_loop`:

```python
def _round_str_to_int(round_str: str | None) -> int:
    """Convert '2-5' to absolute round number 15. Returns 0 if unparseable."""
    if not round_str or "-" not in round_str:
        return 0
    try:
        stage, rnd = round_str.split("-")
        return (int(stage) - 1) * 10 + int(rnd)
    except ValueError:
        return 0
```

And remove the old `current_round = 0` and inline round calculation that was there before (the old code used a local `current_round` int that never updated — the new code derives it from `state.round_number`).

**Step 3: Run all tests**

```bash
.venv/bin/pytest tests/ -v
```
Expected: All tests pass.

**Step 4: Commit**

```bash
git add overlay/main.py
git commit -m "feat: wire StatsRecorder into vision_loop with run/round detection"
```
